/***************************************************************************************************
 *  File Name        : TIMER_program.C
 *  Module           : TIMER_program
 *  Description      : public function
 *  Created on       : May 24, 2021
 *  version          : v 01
 *  Author           : Salsabeel_Essam
 ***************************************************************************************************/

#include"STD_TYPE.h"
#include"BIT_MATH.h"
#include"TIMER_Private.h"
#include"TIMER_Interface.h"
#include"DIO_INTERFACE.h"
#include"TIMER_Config.h"
/************* POINTER to function to call ISR BY CALL BACK FUNCTION  TO TIMER 0 ********/
static volatile void (*Call_Back_TIMER0_NORMAL_MODE_Ptr)(void) = NULL;
static volatile void (*Call_Back_TIMER0_CTC_MODE_Ptr)(void) = NULL;
/************* POITER to function to call ISR BY CALL BACK FUNCTION  TO TIMER 2 ********/
static volatile void (*Call_Back_TIMER2_NORMAL_MODE_Ptr)(void) = NULL;
static volatile void (*Call_Back_TIMER2_CTC_MODE_Ptr)(void) = NULL;

void TIMER0_VoidINT(void) {
	u8 INTI_VALUE_TO_COUNTER = TIMER0_PRELOAD_VALUE;
	u8 COMPARE_VALUE_TO_COUNTER = TIMER0_SET_DUTY_CYCLE;

#if TIMER0_SELECT_MODE == NORMAL_MODE
	// FOC0: set with one in CTC and normal if PWM Always =0
	SET_BIT(TCCR0, FOC0);
	//6==0 ,3==0  that is in Normal Mode
	CLR_BIT(TCCR0, WGM00);
	CLR_BIT(TCCR0, WGM01);
#if TIMER0_COMPARE_MODE_SELECTION == NORMAL_PORT_OPERATION
	//5==0 ,4==0  NORMAL PORT OPERATION NOT USE OC0
	CLR_BIT(TCCR0, COM01);
	CLR_BIT(TCCR0, COM00);
#elif TIMER0_COMPARE_MODE_SELECTION == TOGGLE_OC0_ON_COMPARE_MATCH
	//5==0 ,4==1  Toggle OC2 on compare match
	CLR_BIT(TCCR0, COM01);
	SET_BIT(TCCR0, COM00);
#elif TIMER0_COMPARE_MODE_SELECTION == CLEAR_OC0_ON_COMPARE_MATCH
	//5==1 ,4==0  Clear OC2 on compare match
	SET_BIT(TCCR0, COM01);
	CLR_BIT(TCCR0, COM00);
#elif TIMER0_COMPARE_MODE_SELECTION == SET_OC0_ON_COMPARE_MATCH
	//5==1 ,4==1  Set OC2 on compare match
	SET_BIT(TCCR0, COM01);
	SET_BIT(TCCR0, COM00);
#endif
#elif TIMER0_SELECT_MODE == CTC_MODE
	// FOC0: set with one in CTC and normal if PWM Always =0
	SET_BIT(TCCR0, FOC0);
	//6==0 ,3==1  that is in Compare Mode
	CLR_BIT(TCCR0, WGM00);
	SET_BIT(TCCR0, WGM01);
#if TIMER0_COMPARE_MODE_SELECTION == NORMAL_PORT_OPERATION
	//5==0 ,4==0  NORMAL PORT OPERATION NOT USE OC0
	CLR_BIT(TCCR0, COM01);
	CLR_BIT(TCCR0, COM00);
#elif TIMER0_COMPARE_MODE_SELECTION == TOGGLE_OC0_ON_COMPARE_MATCH
	//5==0 ,4==1  Toggle OC2 on compare match
	CLR_BIT(TCCR0, COM01);
	SET_BIT(TCCR0, COM00);
#elif TIMER0_COMPARE_MODE_SELECTION == CLEAR_OC0_ON_COMPARE_MATCH
	//5==1 ,4==0  Clear OC2 on compare match
	SET_BIT(TCCR0, COM01);
	CLR_BIT(TCCR0, COM00);
#elif TIMER0_COMPARE_MODE_SELECTION == SET_OC0_ON_COMPARE_MATCH
	//5==1 ,4==1  Set OC2 on compare match
	SET_BIT(TCCR0, COM01);
	SET_BIT(TCCR0, COM00);
#endif
#elif TIMER0_SELECT_MODE == FAST_PWM
	// FOC0: set with one in CTC and normal if PWM Always =0
	CLR_BIT(TCCR0, FOC0);
	//6==1 ,3==1  that is in FAST PWM Mode
	SET_BIT(TCCR0, WGM00);
	SET_BIT(TCCR0, WGM01);
#if TIMER0_FAST_PWM_MODE_SELECTION == NON_INVERTED_MODE
	//5==1 ,4==0  Clear OC0 ON compare match (nOn-inverting mode)
	/* Clear OC0 on compare match, set OC0 at BOTTOM,
	 * (non-inverting mode)*/
	SET_BIT(TCCR0, COM01);
	CLR_BIT(TCCR0, COM00);
#elif TIMER0_FAST_PWM_MODE_SELECTION == INVERTED_MODE
	//5==1 ,4==1 SET OC0 ON compare match (inverting mode)
	/* Set OC0 on compare match, clear OC0 at BOTTOM,
	 * (inverting mode)*/
	SET_BIT(TCCR0,COM01);
	SET_BIT(TCCR0,COM00);
#elif TIMER0_FAST_PWM_MODE_SELECTION == NORMAL_PORT_OPERATION
	//5==1 ,4==1 SET OC0 ON compare match (inverting mode)
	CLR_BIT(TCCR0,COM01);
	CLR_BIT(TCCR0,COM00);
#endif
#elif TIMER0_SELECT_MODE == PHASE_CORRECT_MODE
	// FOC0: set with one in CTC and normal if PWM Always =0
	CLR_BIT(TCCR0, FOC0);
	//6==1 ,3==0  that is in PHASE CORRECT PWM Mode
	SET_BIT(TCCR0,WGM00);
	CLR_BIT(TCCR0,WGM01);
#if TIMER0_PHASE_CORRECT_MODE_SELECTION == NON_INVERTED_MODE
	//5==1 ,4==0  Clear OC0 ON compare match (nOn-inverting mode)
	/* Clear OC0 on compare match when up-counting. Set OC0 on compare
	 * match when down counting.*/
	SET_BIT(TCCR0, COM01);
	CLR_BIT(TCCR0, COM00);
#elif TIMER0_PHASE_CORRECT_MODE_SELECTION == INVERTED_MODE
	//5==1 ,4==1 SET OC0 ON compare match (inverting mode)
	/* Set OC0 on compare match when up-counting. Clear OC0 on compare
	 * match when down counting*/
	SET_BIT(TCCR0,COM01);
	SET_BIT(TCCR0,COM00);
#elif TIMER0_PHASE_CORRECT_MODE_SELECTION == NORMAL_PORT_OPERATION
	//5==1 ,4==1 SET OC0 ON compare match (inverting mode)
	CLR_BIT(TCCR0,COM01);
	CLR_BIT(TCCR0,COM00);
#endif
#else
#warning "WRONG INPUT"
#endif



#if TIMER0_NORMAL_MODE_INTERRUPT == ENABLE_INT
	// Overflow Interrupt Enable FOR OVER FLOW MODE NORMAL MODE
	SET_BIT(TIMSK, TOIE0);
#elif  TIMER0_NORMAL_MODE_INTERRUPT == DISABLE_INT
	// Overflow Interrupt DIABLE FOR OVER FLOW MODE NORMAL MODE
	CLR_BIT(TIMSK, TOIE0);
#endif

#if TIMER0_CTC_MODE_INTERRUPT == ENABLE_INT
	// Compare Match Interrupt Enable FOR  COMPARE MODE
	SET_BIT(TIMSK, OCIE0);
#elif  TIMER0_CTC_MODE_INTERRUPT == DISABLE_INT
	// Compare Match Interrupt DISABLE FOR  COMPARE MODE
	CLR_BIT(TIMSK, OCIE0);
#endif

	// TO ASSIGN VALUE IN INITIALIZATION REGISTER TO COUNT FRO THIS VALUE
	ASSIGN_REG(TCNT0, INTI_VALUE_TO_COUNTER);
	// TO ASSIGN VALUE IN OUTPUT COMPARE REGISTER TO COUNT FRO THIS VALUE
	ASSIGN_REG(OCR0, COMPARE_VALUE_TO_COUNTER);


#if TIMER0_PRESCALER_SELECTION == NO_CLCK_SOURCE
	CLR_BIT(TCCR0,CS00);
	CLR_BIT(TCCR0,CS01);
	CLR_BIT(TCCR0,CS02);
#elif TIMER0_PRESCALER_SELECTION == NO_PRECALING
	SET_BIT(TCCR0,CS00);
	CLR_BIT(TCCR0, CS01);
	CLR_BIT(TCCR0, CS02);
#elif TIMER0_PRESCALER_SELECTION == CLCK_DIV_8
	CLR_BIT(TCCR0, CS00);
	SET_BIT(TCCR0, CS01);
	CLR_BIT(TCCR0, CS02);
#elif TIMER0_PRESCALER_SELECTION == CLCK_DIV_64
	SET_BIT(TCCR0, CS00);
	SET_BIT(TCCR0, CS01);
	CLR_BIT(TCCR0, CS02);
#elif TIMER0_PRESCALER_SELECTION == CLCK_DIV_256
	CLR_BIT(TCCR0,CS00);
	CLR_BIT(TCCR0,CS01);
	SET_BIT(TCCR0,CS02);
#elif TIMER0_PRESCALER_SELECTION == CLCK_DIV_1024
	SET_BIT(TCCR0, CS00);
	CLR_BIT(TCCR0, CS01);
	SET_BIT(TCCR0, CS02);
#endif


}
/***********************************************/

//SEt  call back function to TIMER0 IN NORMAL MODE
void TIMER0_NORMAL_MODE_SET_Call_Back(
		void (*TIMER0_NORMAL_MODE_Ptr_to_fun)(void)) {
	Call_Back_TIMER0_NORMAL_MODE_Ptr = TIMER0_NORMAL_MODE_Ptr_to_fun;
}

//SEt  call back function to TIMER0 IN CTC MODE
void TIMER0_CTC_MODE_SET_Call_Back(void (*TIMER0_CTC_MODE_Ptr_to_fun)(void)) {
	Call_Back_TIMER0_CTC_MODE_Ptr = TIMER0_CTC_MODE_Ptr_to_fun;
}
/****************************************************/
void SET_Duty_Cycle_TIMER0(u8 duty) {
	ASSIGN_REG(OCR0, duty);
}

/*************************************************/
/* TIMER 0 ON TW0 MODE NORMAL AND COMPARE MODE*/

// TIMER 0 NORMAL mode
void __vector_11(void) {
	if (Call_Back_TIMER0_NORMAL_MODE_Ptr != NULL) {
		Call_Back_TIMER0_NORMAL_MODE_Ptr();
		// (*Call_Back_TIMER0_NORMAL_MODE_Ptr)();
	}
}
//  TIMER 0 CTC mode
void __vector_10(void) {
	if (Call_Back_TIMER0_CTC_MODE_Ptr != NULL) {
		Call_Back_TIMER0_CTC_MODE_Ptr();
		// (*Call_Back_TIMER0_NORMAL_MODE_Ptr)();
	}
}

/****************************************************************/

/****************************************************************/
void TIMER2_VoidINT(void) {
	u8 INTI_VALUE_TO_COUNTER = 0;
	u8 COMPARE_VALUE_TO_COUNTER = 250;

#if TIMER2_SELECT_MODE == NORMAL_MODE
	// FOC2: set with one in CTC and normal if PWM Always =0
	SET_BIT(TCCR2, FOC2);
	//6==0 ,3==0  that is in Normal Mode
	CLR_BIT(TCCR2, WGM20);
	CLR_BIT(TCCR2, WGM21);
#if TIMER2_COMPARE_MODE_SELECTION == NORMAL_PORT_OPERATION
	//5==0 ,4==0  NORMAL PORT OPERATION NOT USE OC0
	CLR_BIT(TCCR2, COM21);
	CLR_BIT(TCCR2, COM20);
#elif TIMER2_COMPARE_MODE_SELECTION == TOGGLE_OC0_ON_COMPARE_MATCH
	//5==0 ,4==1  Toggle OC2 on compare match
	CLR_BIT(TCCR2, COM21);
	SET_BIT(TCCR2, COM20);
#elif TIMER2_COMPARE_MODE_SELECTION == CLEAR_OC0_ON_COMPARE_MATCH
	//5==1 ,4==0  Clear OC2 on compare match
	SET_BIT(TCCR2, COM21);
	CLR_BIT(TCCR2, COM20);
#elif TIMER2_COMPARE_MODE_SELECTION == SET_OC0_ON_COMPARE_MATCH
	//5==1 ,4==1  Set OC2 on compare match
	SET_BIT(TCCR2, COM21);
	SET_BIT(TCCR2, COM20);
#endif

#elif TIMER2_SELECT_MODE == CTC_MODE
	// FOC2: set with one in CTC and normal if PWM Always =0
	SET_BIT(TCCR2, FOC2);
	//6==0 ,3==1  that is in Compare Mode
	CLR_BIT(TCCR2, WGM20);
	SET_BIT(TCCR2, WGM21);

#if TIMER2_COMPARE_MODE_SELECTION == NORMAL_PORT_OPERATION
	//5==0 ,4==0  NORMAL PORT OPERATION NOT USE OC0
	CLR_BIT(TCCR2, COM21);
	CLR_BIT(TCCR2, COM20);
#elif TIMER2_COMPARE_MODE_SELECTION == TOGGLE_OC0_ON_COMPARE_MATCH
	//5==0 ,4==1  Toggle OC2 on compare match
	CLR_BIT(TCCR2, COM21);
	SET_BIT(TCCR2, COM20);
#elif TIMER2_COMPARE_MODE_SELECTION == CLEAR_OC0_ON_COMPARE_MATCH
	//5==1 ,4==0  Clear OC2 on compare match
	SET_BIT(TCCR2, COM21);
	CLR_BIT(TCCR2, COM20);
#elif TIMER2_COMPARE_MODE_SELECTION == SET_OC0_ON_COMPARE_MATCH
	//5==1 ,4==1  Set OC2 on compare match
	SET_BIT(TCCR2, COM21);
	SET_BIT(TCCR2, COM20);
#endif
#elif TIMER2_SELECT_MODE == FAST_PWM
	// FOC2: set with one in CTC and normal if PWM Always =0
	CLR_BIT(TCCR2, FOC2);
	//6==1 ,3==1  that is in FAST PWM Mode
	SET_BIT(TCCR2, WGM20);
	SET_BIT(TCCR2, WGM21);
#if TIMER2_FAST_PWM_MODE_SELECTION == NON_INVERTED_MODE
	//5==1 ,4==0  Clear OC0 ON compare match (nOn-inverting mode)
	SET_BIT(TCCR2, COM21);
	CLR_BIT(TCCR2, COM20);
#elif TIMER2_FAST_PWM_MODE_SELECTION == INVERTED_MODE
	//5==1 ,4==1 SET OC0 ON compare match (inverting mode)
	SET_BIT(TCCR2,COM21);
	SET_BIT(TCCR2,COM20);
#elif TIMER2_FAST_PWM_MODE_SELECTION == NORMAL_PORT_OPERATION
	//5==1 ,4==1 SET OC0 ON compare match (inverting mode)
	CLR_BIT(TCCR2,COM21);
	CLR_BIT(TCCR2,COM20);
#endif
#elif TIMER2_SELECT_MODE == PHASE_CORRECT_MODE
	// FOC2: set with one in CTC and normal if PWM Always =0
	CLR_BIT(TCCR2, FOC2);
	//6==1 ,3==0  that is in PHASE CORRECT PWM Mode
	SET_BIT(TCCR2,WGM20);
	CLR_BIT(TCCR2,WGM21);
#if TIMER2_PHASE_CORRECT_MODE_SELECTION == NON_INVERTED_MODE
	//5==1 ,4==0  Clear OC0 ON compare match (nOn-inverting mode)
	/* Clear OC2 on compare match when up-counting. Set OC2 on compare
	 * match when down counting.*/
	SET_BIT(TCCR2, COM21);
	CLR_BIT(TCCR2, COM20);
#elif TIMER2_PHASE_CORRECT_MODE_SELECTION == INVERTED_MODE
	//5==1 ,4==1 SET OC0 ON compare match (inverting mode)
	/* Set OC2 on compare match when up-counting. Clear OC2 on compare
	 * match when down counting.*/
	SET_BIT(TCCR2,COM21);
	SET_BIT(TCCR2,COM20);
#elif TIMER2_PHASE_CORRECT_MODE_SELECTION == NORMAL_PORT_OPERATION
	//5==1 ,4==1 SET OC0 ON compare match (inverting mode)
	CLR_BIT(TCCR2,COM21);
	CLR_BIT(TCCR2,COM20);
#endif
#else
#warning "WRONG INPUT"
#endif

#if TIMER2_PRESCALER_SELECTION == NO_CLCK_SOURCE
	CLR_BIT(TCCR2,CS20);
	CLR_BIT(TCCR2,CS21);
	CLR_BIT(TCCR2,CS22);
#elif TIMER2_PRESCALER_SELECTION == NO_PRECALING
	SET_BIT(TCCR2,CS20);
	CLR_BIT(TCCR2, CS21);
	CLR_BIT(TCCR2, CS22);
#elif TIMER2_PRESCALER_SELECTION == CLCK_DIV_8
	CLR_BIT(TCCR2, CS20);
	SET_BIT(TCCR2, CS21);
	CLR_BIT(TCCR2, CS22);
#elif TIMER2_PRESCALER_SELECTION == CLCK_DIV_32
	CLR_BIT(TCCR2, CS20);
	SET_BIT(TCCR2, CS21);
	CLR_BIT(TCCR2, CS22);
#elif TIMER2_PRESCALER_SELECTION == CLCK_DIV_64
	SET_BIT(TCCR2,CS20);
	SET_BIT(TCCR2,CS21);
	CLR_BIT(TCCR2,CS22);
#elif TIMER2_PRESCALER_SELECTION == CLCK_DIV_128
	SET_BIT(TCCR2,CS20);
	SET_BIT(TCCR2,CS21);
	CLR_BIT(TCCR2,CS22);
#elif TIMER2_PRESCALER_SELECTION == CLCK_DIV_256
	CLR_BIT(TCCR2, CS20);
	CLR_BIT(TCCR2, CS21);
	SET_BIT(TCCR2, CS22);
#elif TIMER2_PRESCALER_SELECTION == CLCK_DIV_1024
	SET_BIT(TCCR2, CS20);
	CLR_BIT(TCCR2, CS21);
	SET_BIT(TCCR2, CS22);
#endif

#if TIMER2_NORMAL_MODE_INTERRUPT == ENABLE_INT
	// Overflow Interrupt Enable FOR OVER FLOW MODE NORMAL MODE
	SET_BIT(TIMSK, TOIE2);
#elif  TIMER2_NORMAL_MODE_INTERRUPT == DISABLE_INT
	// Overflow Interrupt DIABLE FOR OVER FLOW MODE NORMAL MODE
	CLR_BIT(TIMSK, TOIE2);
#endif

#if TIMER2_CTC_MODE_INTERRUPT == ENABLE_INT
	// Compare Match Interrupt Enable FOR  COMPARE MODE
	SET_BIT(TIMSK, OCIE2);
#elif  TIMER2_CTC_MODE_INTERRUPT == DISABLE_INT
	// Compare Match Interrupt DISABLE FOR  COMPARE MODE
	CLR_BIT(TIMSK, OCIE2);
#endif

	// TO ASSIGN VALUE IN INITIALIZATION REGISTER TO COUNT FRO THIS VALUE
	ASSIGN_REG(TCNT2, INTI_VALUE_TO_COUNTER);
	// TO ASSIGN VALUE IN OUTPUT COMPARE REGISTER TO COUNT FRO THIS VALUE
	ASSIGN_REG(OCR2, COMPARE_VALUE_TO_COUNTER);

}
/***********************************************************/
//SEt  call back function to TIMER2 IN NORMAL MODE
void TIMER2_NORMAL_MODE_SET_Call_Back(
		void (*TIMER2_NORMAL_MODE_Ptr_to_fun)(void)) {
	Call_Back_TIMER2_NORMAL_MODE_Ptr = TIMER2_NORMAL_MODE_Ptr_to_fun;
}

//SEt  call back function to TIMER2 IN CTC MODE
void TIMER2_CTC_MODE_SET_Call_Back(void (*TIMER2_CTC_MODE_Ptr_to_fun)(void)) {
	Call_Back_TIMER2_CTC_MODE_Ptr = TIMER2_CTC_MODE_Ptr_to_fun;
}
/***********************************************************/
void SET_Duty_Cycle_TIMER2(u8 duty) {
	ASSIGN_REG(OCR2, duty);
}
/***********************************************/
/* TIMER 2 ON TW0 MODE NORMAL AND COMPARE MODE*/

// TIMER 2 NORMAL mode
void __vector_5(void) {
	if (Call_Back_TIMER2_NORMAL_MODE_Ptr != NULL) {
		Call_Back_TIMER2_NORMAL_MODE_Ptr();
		// (*Call_Back_TIMER0_NORMAL_MODE_Ptr)();
	}
}
//  TIMER 2 CTC mode
void __vector_4(void) {
	if (Call_Back_TIMER2_CTC_MODE_Ptr != NULL) {
		Call_Back_TIMER2_CTC_MODE_Ptr();
		// (*Call_Back_TIMER0_NORMAL_MODE_Ptr)();
	}
}

/****************************************************************/

void TIMER1_VoidINT(void) {
	u16 INTI_VALUE_TO_COUNTER = 0;
	u16 COMPARE_VALUE_A_TO_COUNTER = 750;
	u16 COMPARE_VALUE_B_TO_COUNTER = 0;
	u16 INPUT_CAPTURE_VALUE_TO_COUNTER = 19999;

	// TO ASSIGN VALUE IN INITIALIZATION REGISTER TO COUNT FRO THIS VALUE
	ASSIGN_REG(TCNT1, INTI_VALUE_TO_COUNTER);
	// TO ASSIGN VALUE IN OUTPUT COMPARE  A REGISTER TO COUNT FRO THIS VALUE
	ASSIGN_REG(OCR1A, COMPARE_VALUE_A_TO_COUNTER);
	 // TO ASSIGN VALUE IN OUTPUT COMPARE B  REGISTER TO COUNT FRO THIS VALUE
	 ASSIGN_REG(OCR1B, COMPARE_VALUE_B_TO_COUNTER);
	 // TO ASSIGN VALUE IN OUTPUTINPUT CAPUTERE  REGISTER TO COUNT FRO THIS VALUE
	ASSIGN_REG(ICR1, INPUT_CAPTURE_VALUE_TO_COUNTER);


#if TIMER1_SELECT_MODE == NORMAL_MODE_TIMER1
	/* IN NORAL MODE WE BUT IN TWO REGISTER ALL 0*/
	CLR_BIT(TCCR1A, WGM10);
	CLR_BIT(TCCR1A, WGM11);
	CLR_BIT(TCCR1B, WGM12);
	CLR_BIT(TCCR1B, WGM13);
	/* FORC OUTPUT COMPARE MODE UNIT*/
	SET_BIT(TCCR1A, FOC1B);
	SET_BIT(TCCR1A, FOC1A);

	/* COMPARE OUTPUT MODE */
#if TIMER1_COMPARE_A_MODE_SELECTION == NORMAL_PORT_OPERATION
	CLR_BIT(TCCR1A, COM1A0);
	CLR_BIT(TCCR1A, COM1A1);
#elif TIMER1_COMPARE_A_MODE_SELECTION == TOGGLE_OC1_A_B_ON_COMPARE_MATCH
	SET_BIT(TCCR1A,COM1A0);
	CLR_BIT(TCCR1A,COM1A1);
#elif TIMER1_COMPARE_A_MODE_SELECTION == CLEAR_OC1_A_B_ON_COMPARE_MATCH
	CLR_BIT(TCCR1A,COM1A0);
	SET_BIT(TCCR1A,COM1A1);
#elif TIMER1_COMPARE_A_MODE_SELECTION == SET_OC1_A_B_ON_COMPARE_MATCH
	SET_BIT(TCCR1A,COM1A0);
	SET_BIT(TCCR1A,COM1A1);
#endif

#if TIMER1_COMPARE_B_MODE_SELECTION == NORMAL_PORT_OPERATION
	CLR_BIT(TCCR1A, COM1B0);
	CLR_BIT(TCCR1A, COM1B1);
#elif TIMER1_COMPARE_B_MODE_SELECTION == TOGGLE_OC1_A_B_ON_COMPARE_MATCH
	SET_BIT(TCCR1A,COM1B0);
	CLR_BIT(TCCR1A,COM1B1);
#elif TIMER1_COMPARE_B_MODE_SELECTION == CLEAR_OC1_A_B_ON_COMPARE_MATCH
	CLR_BIT(TCCR1A,COM1B0);
	SET_BIT(TCCR1A,COM1B1);
#elif TIMER1_COMPARE_B_MODE_SELECTION == SET_OC1_A_B_ON_COMPARE_MATCH
	SET_BIT(TCCR1A,COM1B0);
	SET_BIT(TCCR1A,COM1B1);
#endif

#elif TIMER1_SELECT_MODE == CTC_MODE_OCR1
	/* IN NORAL MODE WE BUT IN TWO REGISTER ALL 0*/
	CLR_BIT(TCCR1A,WGM10);
	CLR_BIT(TCCR1A,WGM11);
	SET_BIT(TCCR1B,WGM12);
	CLR_BIT(TCCR1B,WGM13);
	/* FORC OUTPUT COMPARE MODE UNIT*/
	SET_BIT(TCCR1A,FOC1B);
	SET_BIT(TCCR1A,FOC1A);
	/* COMPARE OUTPUT MODE */
#if TIMER1_COMPARE_A_MODE_SELECTION == NORMAL_PORT_OPERATION
	CLR_BIT(TCCR1A,COM1A0);
	CLR_BIT(TCCR1A,COM1A1);
#elif TIMER1_COMPARE_A_MODE_SELECTION == TOGGLE_OC1_A_B_ON_COMPARE_MATCH
	SET_BIT(TCCR1A,COM1A0);
	CLR_BIT(TCCR1A,COM1A1);
#elif TIMER1_COMPARE_A_MODE_SELECTION == CLEAR_OC1_A_B_ON_COMPARE_MATCH
	CLR_BIT(TCCR1A,COM1A0);
	SET_BIT(TCCR1A,COM1A1);
#elif TIMER1_COMPARE_A_MODE_SELECTION == SET_OC1_A_B_ON_COMPARE_MATCH
	SET_BIT(TCCR1A,COM1A0);
	SET_BIT(TCCR1A,COM1A1);
#endif

#if TIMER1_COMPARE_B_MODE_SELECTION == NORMAL_PORT_OPERATION
	CLR_BIT(TCCR1A,COM1B0);
	CLR_BIT(TCCR1A,COM1B1);
#elif TIMER1_COMPARE_B_MODE_SELECTION == TOGGLE_OC1_A_B_ON_COMPARE_MATCH
	SET_BIT(TCCR1A,COM1B0);
	CLR_BIT(TCCR1A,COM1B1);
#elif TIMER1_COMPARE_B_MODE_SELECTION == CLEAR_OC1_A_B_ON_COMPARE_MATCH
	CLR_BIT(TCCR1A,COM1B0);
	SET_BIT(TCCR1A,COM1B1);
#elif TIMER1_COMPARE_B_MODE_SELECTION == SET_OC1_A_B_ON_COMPARE_MATCH
	SET_BIT(TCCR1A,COM1B0);
	SET_BIT(TCCR1A,COM1B1);
#endif

#elif TIMER1_SELECT_MODE == FAST_PWM_OCR1
	/* IN FAST PWM OCR1 MODE WE BUT IN TWO REGISTER ALL 0*/
	SET_BIT(TCCR1A, WGM10);
	SET_BIT(TCCR1A, WGM11);
	SET_BIT(TCCR1B, WGM12);
	SET_BIT(TCCR1B, WGM13);

	/* FORC OUTPUT COMPARE MODE UNIT*/
	CLR_BIT(TCCR1A, FOC1B);
	CLR_BIT(TCCR1A, FOC1A);

	/* COMPARE OUTPUT MODE */
#if TIMER1_FAST_PWM_MODE_A_SELECTION == NORMAL_PORT_OPERATION
	CLR_BIT(TCCR1A, COM1A0);
	CLR_BIT(TCCR1A, COM1A1);
#elif TIMER1_FAST_PWM_MODE_A_SELECTION == TOGGLE_OCR1A_COMPARE_OC1B_DISCONNECTED
	/*Toggle OC1A on Compare Match, OC1B disconnected (normal port operation).*/
	SET_BIT(TCCR1A,COM1A0);
	CLR_BIT(TCCR1A,COM1A1);
#elif TIMER1_FAST_PWM_MODE_A_SELECTION == NON_INVERTED_MODE
	/*Clear OC1A/OC1B on compare match, set OC1A/OC1B at BOTTOM,*/
	CLR_BIT(TCCR1A,COM1A0);
	SET_BIT(TCCR1A,COM1A1);
#elif TIMER1_FAST_PWM_MODE_A_SELECTION == INVERTED_MODE
	/*Set OC1A/OC1B on compare match, clear OC1A/OC1B at BOTTOM,*/
	SET_BIT(TCCR1A,COM1A0);
	SET_BIT(TCCR1A,COM1A1);
#endif

#if TIMER1_FAST_PWM_MODE_B_SELECTION == NORMAL_PORT_OPERATION
	CLR_BIT(TCCR1A, COM1B0);
	CLR_BIT(TCCR1A, COM1B1);
#elif TIMER1_FAST_PWM_MODE_B_SELECTION == TOGGLE_OCR1A_COMPARE_OC1B_DISCONNECTED
	/*Toggle OC1A on Compare Match, OC1B disconnected (normal port operation).*/
	SET_BIT(TCCR1A,COM1B0);
	CLR_BIT(TCCR1A,COM1B1);
#elif TIMER1_FAST_PWM_MODE_B_SELECTION == NON_INVERTED_MODE
	/*Clear OC1A/OC1B on compare match, set OC1A/OC1B at BOTTOM,*/
	CLR_BIT(TCCR1A,COM1B0);
	SET_BIT(TCCR1A,COM1B1);
#elif TIMER1_FAST_PWM_MODE_B_SELECTION == INVERTED_MODE
	/*Set OC1A/OC1B on compare match, clear OC1A/OC1B at BOTTOM,*/
	SET_BIT(TCCR1A,COM1B0);
	SET_BIT(TCCR1A,COM1B1);
#endif

#elif TIMER1_SELECT_MODE == FAST_PWM_ICR1
	/* IN FAST PWM ICR1 MODE WE BUT IN TWO REGISTER ALL 0*/
	CLR_BIT(TCCR1A,WGM10);
	SET_BIT(TCCR1A,WGM11);
	SET_BIT(TCCR1B,WGM12);
	SET_BIT(TCCR1B,WGM13);
	/* FORC OUTPUT COMPARE MODE UNIT*/
	CLR_BIT(TCCR1A,FOC1B);
	CLR_BIT(TCCR1A,FOC1A);
	/* COMPARE OUTPUT MODE */
#if TIMER1_FAST_PWM_MODE_A_SELECTION == NORMAL_PORT_OPERATION
	CLR_BIT(TCCR1A, COM1A0);
	CLR_BIT(TCCR1A, COM1A1);
#elif TIMER1_FAST_PWM_MODE_A_SELECTION == TOGGLE_OCR1A_COMPARE_OC1B_DISCONNECTED
	/*Toggle OC1A on Compare Match, OC1B disconnected (normal port operation).*/
	SET_BIT(TCCR1A,COM1A0);
	CLR_BIT(TCCR1A,COM1A1);
#elif TIMER1_FAST_PWM_MODE_A_SELECTION == NON_INVERTED_MODE
	/*Clear OC1A/OC1B on compare match, set OC1A/OC1B at BOTTOM,*/
	CLR_BIT(TCCR1A,COM1A0);
	SET_BIT(TCCR1A,COM1A1);
#elif TIMER1_FAST_PWM_MODE_A_SELECTION == INVERTED_MODE
	/*Set OC1A/OC1B on compare match, clear OC1A/OC1B at BOTTOM,*/
	SET_BIT(TCCR1A,COM1A0);
	SET_BIT(TCCR1A,COM1A1);
#endif

#if TIMER1_FAST_PWM_MODE_B_SELECTION == NORMAL_PORT_OPERATION
	CLR_BIT(TCCR1A, COM1B0);
	CLR_BIT(TCCR1A, COM1B1);
#elif TIMER1_FAST_PWM_MODE_B_SELECTION == TOGGLE_OCR1A_COMPARE_OC1B_DISCONNECTED
	/*Toggle OC1A on Compare Match, OC1B disconnected (normal port operation).*/
	SET_BIT(TCCR1A,COM1B0);
	CLR_BIT(TCCR1A,COM1B1);
#elif TIMER1_FAST_PWM_MODE_B_SELECTION == NON_INVERTED_MODE
	/*Clear OC1A/OC1B on compare match, set OC1A/OC1B at BOTTOM,*/
	CLR_BIT(TCCR1A,COM1B0);
	SET_BIT(TCCR1A,COM1B1);
#elif TIMER1_FAST_PWM_MODE_B_SELECTION == INVERTED_MODE
	/*Set OC1A/OC1B on compare match, clear OC1A/OC1B at BOTTOM,*/
	SET_BIT(TCCR1A,COM1B0);
	SET_BIT(TCCR1A,COM1B1);
#endif
#elif TIMER1_SELECT_MODE == CTC_MODE_ICR1
	/* IN CTC MODE ICR1 MODE WE BUT IN TWO REGISTER ALL 0*/
	CLR_BIT(TCCR1A,WGM10);
	CLR_BIT(TCCR1A,WGM11);
	SET_BIT(TCCR1B,WGM12);
	SET_BIT(TCCR1B,WGM13);
	/* FORC OUTPUT COMPARE MODE UNIT*/
	SET_BIT(TCCR1A,FOC1B);
	SET_BIT(TCCR1A,FOC1A);

#endif
#if TIMER1_INPUT_CAPTURE_NOISE_CANCELER == DISABLE_CANCELER
	CLR_BIT(TCCR1B, ICNC1);
#elif TIMER1_INPUT_CAPTURE_NOISE_CANCELER == ENABLE_CANCELER
	SET_BIT(TCCR1B,ICNC1);
#endif

#if TIMER1_INPUT_CAPTURE_EDGE_SELECT == RISING_EDGE
	SET_BIT(TCCR1B,ICES1);
#elif TIMER1_INPUT_CAPTURE_EDGE_SELECT == FALLING_EDGE
	CLR_BIT(TCCR1B, ICES1);
#endif



#if TIMER1_NORMAL_MODE_INTERRUPT == ENABLE_INT
	// Overflow Interrupt Enable FOR OVER FLOW MODE NORMAL MODE
	SET_BIT(TIMSK, TOIE1);
#elif  TIMER1_NORMAL_MODE_INTERRUPT == DISABLE_INT
	// Overflow Interrupt DIABLE FOR OVER FLOW MODE NORMAL MODE
	CLR_BIT(TIMSK, TOIE1);
#endif

#if TIMER1_CTC_A_MODE_INTERRUPT == ENABLE_INT
	// Compare Match Interrupt Enable FOR  COMPARE MODE
	SET_BIT(TIMSK, OCIE1A);
#elif  TIMER1_CTC_A_MODE_INTERRUPT == DISABLE_INT
	// Compare Match Interrupt DISABLE FOR  COMPARE MODE
	CLR_BIT(TIMSK, OCIE1A);
#endif

#if TIMER1_CTC_B_MODE_INTERRUPT == ENABLE_INT
	// Compare Match Interrupt Enable FOR  COMPARE MODE
	SET_BIT(TIMSK, OCIE1B);
#elif  TIMER1_CTC_B_MODE_INTERRUPT == DISABLE_INT
	// Compare Match Interrupt DISABLE FOR  COMPARE MODE
	CLR_BIT(TIMSK, OCIE1B);
#endif

#if TIMER1_INPUT_CAPTURE_MODE_INTERRUPT == ENABLE_INT
	// Compare Match Interrupt Enable FOR  COMPARE MODE
	SET_BIT(TIMSK, TICIE1);
#elif  TIMER1_INPUT_CAPTURE_MODE_INTERRUPT == DISABLE_INT
	// Compare Match Interrupt DISABLE FOR  COMPARE MODE
	CLR_BIT(TIMSK, TICIE1);
#endif

#if TIMER1_PRESCALER_SELECTION == NO_CLCK_SOURCE
	CLR_BIT(TCCR1B,CS10);
	CLR_BIT(TCCR1B,CS11);
	CLR_BIT(TCCR1B,CS12);
#elif TIMER1_PRESCALER_SELECTION == NO_PRECALING
	SET_BIT(TCCR1B,CS10);
	CLR_BIT(TCCR1B,CS11);
	CLR_BIT(TCCR1B,CS12);
#elif TIMER1_PRESCALER_SELECTION == CLCK_DIV_8
	CLR_BIT(TCCR1B, CS10);
	SET_BIT(TCCR1B, CS11);
	CLR_BIT(TCCR1B, CS12);
#elif TIMER1_PRESCALER_SELECTION == CLCK_DIV_64
	SET_BIT(TCCR1B,CS10);
	SET_BIT(TCCR1B,CS11);
	CLR_BIT(TCCR1B,CS12);
#elif TIMER1_PRESCALER_SELECTION == CLCK_DIV_256
	CLR_BIT(TCCR1B, CS10);
	CLR_BIT(TCCR1B, CS11);
	SET_BIT(TCCR1B, CS12);
#elif TIMER1_PRESCALER_SELECTION == CLCK_DIV_1024
	SET_BIT(TCCR1B,CS10);
	CLR_BIT(TCCR1B,CS11);
	SET_BIT(TCCR1B,CS12);
#endif

}
/*********************************************************************/
void SET_Duty_Cycle_TIMER1(u16 angle) {
	u16 degree = (2098 /180 ) * angle;
	degree = degree +750;
	ASSIGN_REG(OCR1A,degree );
}

/*******************************************************************/
/* TIMER 1 ON TW0 MODE NORMAL AND COMPARE MODE*/

// TIMER 1 CAAPTURE MODE
void __vector_6(void) {
//	DIO_TogPinValue(PORTD, PIN7);
}
//  TIMER 1 CTC COMPARE A  mode
void __vector_7(void) {
   DIO_TogPinValue(PORTD, PIN7);
}

// TIMER 1 CTC COMPARE B mode
void __vector_8(void) {
//	DIO_TogPinValue(PORTD, PIN7);
}
//  TIMER 1 OVERFLOW  mode
void __vector_9(void) {
//	DIO_TogPinValue(PORTD, PIN7);
}


/*********************************************************************/
void TIMER1_GET_COUNTER_VALUE(u16 *counter_value){
	(*counter_value) = (TCNT1);

}
