/*
 * ADC_Program.c
 *
 *  Created on: Jun 8, 2021
 *      Author: Salsabeel Essam
 */

#include"STD_TYPE.h"
#include"BIT_MATH.h"
#include"ADC_Interface.h"
#include"ADC_Config.h"
#include"ADC_Private.h"

void ADC_VoidInit(void) {
	/*SELECT  MAX VOLT*/
#if ADC_VOLTAGE_REFERENCE == AREF_INTERNAL_VREF_TURNED_OFF
	CLR_BIT(ADMUX, REFS0);
	CLR_BIT(ADMUX, REFS1);
#elif ADC_VOLTAGE_REFERENCE == AVCC_AT_AREF_PIN
	SET_BIT(ADMUX, REFS0);
	CLR_BIT(ADMUX, REFS1);
#elif ADC_VOLTAGE_REFERENCE == INTERNAL_2_56_VOLTAGE_REFERENCE
	SET_BIT(ADMUX,REFS0);
	SET_BIT(ADMUX,REFS1);
#endif

	/*LEFT ADJUSTMENT */
#if ADC_PRESENTATION_CONVERSION_THE_RESULT == LEFT_ADJUST_THE_RESULT
	SET_BIT(ADMUX, ADLAR);
#elif ADC_PRESENTATION_CONVERSION_THE_RESULT == RIGHT_ADJUST_THE_RESULT
	CLR_BIT(ADMUX,ADLAR);
#endif
	/* CONVERSTION MODE SIGLE CONVERSTION MODE OR FREE RUNNING*/
#if ADC_START_CONVERTION_IN_MODE ==  ADC_SINGLE_CONVERSTION_MODE
	//SET_BIT(ADCSRA, ADSC);
	CLR_BIT(ADCSRA,ADATE);
#elif ADC_START_CONVERTION_IN_MODE ==  ADC_OUTO_TRIGGER_MODE
	SET_BIT(ADCSRA,ADATE);
	/*may be in free running mode
	 * or external interrupt or timer*/
#endif



	/* PRESCALER*/
#if ADC_PRESCLER_SELECTION == CLCK_DIV_2
	CLR_BIT(ADCSRA, ADPS0);
	CLR_BIT(ADCSRA, ADPS1);
	CLR_BIT(ADCSRA, ADPS2);
#elif ADC_PRESCLER_SELECTION == CLCK_DIV_2_2
	SET_BIT(ADCSRA, ADPS0);
	CLR_BIT(ADCSRA, ADPS1);
	CLR_BIT(ADCSRA, ADPS2);
#elif ADC_PRESCLER_SELECTION == CLCK_DIV_4
	CLR_BIT(ADCSRA, ADPS0);
	SET_BIT(ADCSRA, ADPS1);
	CLR_BIT(ADCSRA, ADPS2);
#elif ADC_PRESCLER_SELECTION == CLCK_DIV_8
	SET_BIT(ADCSRA, ADPS0);
	SET_BIT(ADCSRA, ADPS1);
	CLR_BIT(ADCSRA, ADPS2);
#elif ADC_PRESCLER_SELECTION == CLCK_DIV_16
	CLR_BIT(ADCSRA, ADPS0);
	CLR_BIT(ADCSRA, ADPS1);
	SET_BIT(ADCSRA, ADPS2);
#elif ADC_PRESCLER_SELECTION == CLCK_DIV_32
	SET_BIT(ADCSRA, ADPS0);
	CLR_BIT(ADCSRA, ADPS1);
	SET_BIT(ADCSRA, ADPS2);
#elif ADC_PRESCLER_SELECTION == CLCK_DIV_64
	CLR_BIT(ADCSRA, ADPS0);
	SET_BIT(ADCSRA, ADPS1);
	SET_BIT(ADCSRA, ADPS2);
#elif ADC_PRESCLER_SELECTION == CLCK_DIV_128
	SET_BIT(ADCSRA, ADPS0);
	SET_BIT(ADCSRA, ADPS1);
	SET_BIT(ADCSRA, ADPS2);
#endif

	/* ADC ENABLE*/
#if ADC_ENABLE_TURNED_ON == ADC_ENABLE
	SET_BIT(ADCSRA, ADEN);
#elif ADC_ENABLE_TURNED_ON == ADC_DISABLE
	CLR_BIT(ADCSRA,ADEN);
#endif

}

void ADC_EnableInterrupt(void);
void ADC_DisableInterrupt(void);

void ADC_GetDigitalValue(u8 Copy_u8Channel, u16 *Copy_DigitalValue) {
       /* check  that Copy_u8Channel not more than i have in data sheet */
	if ((Copy_u8Channel < 32) && (Copy_u8Channel != NULL)) {

	}
	        ADMUX &= 0b11100000;
		//	Copy_u8Channel &= 0b00011111;
			ADMUX |= Copy_u8Channel;
			/*start conversion */
			SET_BIT(ADCSRA, ADSC);
			/* WAIT FOR THE FALG OF ADC*/
	//		while( (GET_BIT(ADCSRA,ADIF))  == 0);
			while (!(GET_BIT(ADCSRA, ADIF))); /*POLLING*/

			/* CLEAR FLAG NOT DONE BY HARDWARE */
			SET_BIT(ADCSRA, ADIF);
			/* READ THE VALUE OF REGISTER AFTER CONVERTION*/
			(*Copy_DigitalValue) = ADC;
}

